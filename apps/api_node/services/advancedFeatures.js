/**
 * ECONEURA - Capacidades Avanzadas ChatGPT
 * 
 * M√≥dulo que a√±ade todas las funciones de ChatGPT a los agentes NEURA:
 * ‚úÖ B√∫squeda web (informaci√≥n actualizada)
 * ‚úÖ An√°lisis de im√°genes (GPT-4 Vision)
 * ‚úÖ Generaci√≥n de im√°genes (DALL-E 3)
 * ‚úÖ Code Interpreter (ejecutar Python)
 * ‚úÖ An√°lisis de documentos (PDF, Word, Excel)
 * ‚úÖ Function calling (acceso a datos internos)
 */

const OpenAI = require('openai');
const axios = require('axios');

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
});

// ============================================
// üîç B√öSQUEDA WEB (informaci√≥n actualizada)
// ============================================

async function webSearch(query) {
    /**
     * Buscar informaci√≥n actualizada en la web
     * Usa Bing Search API o alternativa
     */
    
    // Opci√≥n 1: Bing Search (requiere BING_API_KEY)
    if (process.env.BING_API_KEY) {
        try {
            const response = await axios.get('https://api.bing.microsoft.com/v7.0/search', {
                headers: {
                    'Ocp-Apim-Subscription-Key': process.env.BING_API_KEY
                },
                params: {
                    q: query,
                    count: 5,
                    mkt: 'es-ES'
                }
            });
            
            return {
                results: response.data.webPages?.value?.map(page => ({
                    title: page.name,
                    url: page.url,
                    snippet: page.snippet
                })) || [],
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            console.error('Error en b√∫squeda web:', error.message);
        }
    }
    
    // Opci√≥n 2: Simulaci√≥n con fecha actual
    return {
        results: [{
            title: "Informaci√≥n actualizada no disponible",
            snippet: `Fecha actual: ${new Date().toLocaleString('es-ES')}. Configure BING_API_KEY para b√∫squedas reales.`
        }],
        simulated: true
    };
}

// ============================================
// üëÅÔ∏è AN√ÅLISIS DE IM√ÅGENES (GPT-4 Vision)
// ============================================

async function analyzeImage(imageUrl, question = "¬øQu√© ves en esta imagen?") {
    /**
     * Analizar una imagen usando GPT-4 Vision
     * Puede procesar im√°genes desde URL o base64
     */
    
    try {
        const response = await openai.chat.completions.create({
            model: "gpt-4o",  // Modelo con capacidad de visi√≥n
            messages: [
                {
                    role: "user",
                    content: [
                        { type: "text", text: question },
                        {
                            type: "image_url",
                            image_url: {
                                url: imageUrl,
                                detail: "high"  // "high" para an√°lisis detallado
                            }
                        }
                    ]
                }
            ],
            max_tokens: 1000
        });
        
        return {
            analysis: response.choices[0].message.content,
            model: "gpt-4o-vision",
            usage: response.usage
        };
    } catch (error) {
        console.error('Error analizando imagen:', error.message);
        throw new Error(`No se pudo analizar la imagen: ${error.message}`);
    }
}

// ============================================
// üé® GENERACI√ìN DE IM√ÅGENES (DALL-E 3)
// ============================================

async function generateImage(prompt, options = {}) {
    /**
     * Generar im√°genes con DALL-E 3
     * Calidad profesional, ideal para marketing, presentaciones
     */
    
    const {
        size = "1024x1024",  // "1024x1024", "1792x1024", "1024x1792"
        quality = "standard",  // "standard" o "hd"
        style = "vivid"  // "vivid" o "natural"
    } = options;
    
    try {
        const response = await openai.images.generate({
            model: "dall-e-3",
            prompt: prompt,
            n: 1,
            size: size,
            quality: quality,
            style: style
        });
        
        return {
            url: response.data[0].url,
            revisedPrompt: response.data[0].revised_prompt,  // OpenAI mejora el prompt
            model: "dall-e-3",
            size: size,
            quality: quality
        };
    } catch (error) {
        console.error('Error generando imagen:', error.message);
        throw new Error(`No se pudo generar imagen: ${error.message}`);
    }
}

// ============================================
// üêç CODE INTERPRETER (ejecutar c√≥digo)
// ============================================

async function executeCode(code, language = 'python') {
    /**
     * Ejecutar c√≥digo en sandbox seguro
     * NOTA: Requiere servicio externo o Docker para seguridad
     */
    
    // Opci√≥n 1: Usar OpenAI Assistants con Code Interpreter
    if (process.env.USE_OPENAI_CODE_INTERPRETER === 'true') {
        try {
            // Crear thread
            const thread = await openai.beta.threads.create();
            
            // A√±adir mensaje con c√≥digo
            await openai.beta.threads.messages.create(thread.id, {
                role: "user",
                content: `Ejecuta este c√≥digo ${language}:\n\n${code}`
            });
            
            // Ejecutar con code interpreter habilitado
            const run = await openai.beta.threads.runs.create(thread.id, {
                assistant_id: process.env.OPENAI_ASSISTANT_ID,
                tools: [{ type: "code_interpreter" }]
            });
            
            // Esperar resultado
            let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
            while (runStatus.status === 'in_progress' || runStatus.status === 'queued') {
                await new Promise(resolve => setTimeout(resolve, 1000));
                runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
            }
            
            // Obtener resultado
            const messages = await openai.beta.threads.messages.list(thread.id);
            const lastMessage = messages.data[0];
            
            return {
                output: lastMessage.content[0].text.value,
                status: 'success',
                method: 'openai-code-interpreter'
            };
        } catch (error) {
            console.error('Error en code interpreter:', error.message);
        }
    }
    
    // Opci√≥n 2: Simulaci√≥n (SOLO para demo - NO ejecutar c√≥digo real sin sandbox)
    return {
        output: `[SIMULACI√ìN] C√≥digo ${language} recibido. Configure code interpreter para ejecuci√≥n real.`,
        code: code,
        status: 'simulated',
        warning: '‚ö†Ô∏è Ejecuci√≥n de c√≥digo requiere sandbox seguro'
    };
}

// ============================================
// üìÑ AN√ÅLISIS DE DOCUMENTOS
// ============================================

async function analyzeDocument(fileContent, fileType, question) {
    /**
     * Analizar documentos: PDF, Word, Excel, CSV
     * Extrae texto y analiza contenido con GPT-4
     */
    
    let extractedText = '';
    
    // Seg√∫n tipo de archivo, extraer texto
    switch (fileType) {
        case 'pdf':
            // Requiere: npm install pdf-parse
            extractedText = '[PDF] Instalar pdf-parse para procesamiento real';
            break;
        case 'docx':
            // Requiere: npm install mammoth
            extractedText = '[DOCX] Instalar mammoth para procesamiento real';
            break;
        case 'xlsx':
        case 'csv':
            // Requiere: npm install xlsx
            extractedText = '[Excel/CSV] Instalar xlsx para procesamiento real';
            break;
        default:
            extractedText = fileContent;
    }
    
    // Analizar con GPT-4
    try {
        const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: [
                {
                    role: "system",
                    content: "Eres un experto analizando documentos. Proporciona an√°lisis claros y precisos."
                },
                {
                    role: "user",
                    content: `Documento:\n${extractedText}\n\nPregunta: ${question}`
                }
            ],
            max_tokens: 2000
        });
        
        return {
            analysis: response.choices[0].message.content,
            fileType: fileType,
            extractedLength: extractedText.length,
            usage: response.usage
        };
    } catch (error) {
        console.error('Error analizando documento:', error.message);
        throw error;
    }
}

// ============================================
// üõ†Ô∏è FUNCTION CALLING (Tools)
// ============================================

const AVAILABLE_FUNCTIONS = {
    // Funci√≥n: Obtener datos financieros
    get_financial_data: async (params) => {
        const { metric, period } = params;
        // Aqu√≠ conectar√≠as a tu DB o API interna
        return {
            metric: metric,
            period: period,
            value: 1234567,
            currency: 'USD',
            source: 'internal_db',
            timestamp: new Date().toISOString()
        };
    },
    
    // Funci√≥n: B√∫squeda en base de conocimiento
    search_knowledge_base: async (params) => {
        const { query, category } = params;
        // Aqu√≠ buscar√≠as en tu documentaci√≥n interna
        return {
            results: [
                {
                    title: 'Resultado de b√∫squeda simulado',
                    content: 'Configure esta funci√≥n para b√∫squedas reales',
                    category: category
                }
            ]
        };
    },
    
    // Funci√≥n: Obtener datos de usuario
    get_user_profile: async (params) => {
        const { userId } = params;
        // Aqu√≠ consultar√≠as tu DB de usuarios
        return {
            userId: userId,
            name: 'Usuario Simulado',
            role: 'CFO',
            preferences: {}
        };
    },
    
    // Funci√≥n: B√∫squeda web
    web_search: async (params) => {
        return await webSearch(params.query);
    }
};

// Definiciones de funciones para OpenAI
const FUNCTION_DEFINITIONS = [
    {
        name: "get_financial_data",
        description: "Obtiene datos financieros de la empresa",
        parameters: {
            type: "object",
            properties: {
                metric: {
                    type: "string",
                    description: "M√©trica financiera (revenue, profit, expenses, etc.)"
                },
                period: {
                    type: "string",
                    description: "Per√≠odo (current_month, current_quarter, current_year)"
                }
            },
            required: ["metric", "period"]
        }
    },
    {
        name: "search_knowledge_base",
        description: "Busca informaci√≥n en la base de conocimiento interna",
        parameters: {
            type: "object",
            properties: {
                query: {
                    type: "string",
                    description: "Consulta de b√∫squeda"
                },
                category: {
                    type: "string",
                    description: "Categor√≠a (policies, procedures, documentation)"
                }
            },
            required: ["query"]
        }
    },
    {
        name: "web_search",
        description: "Busca informaci√≥n actualizada en la web",
        parameters: {
            type: "object",
            properties: {
                query: {
                    type: "string",
                    description: "Consulta de b√∫squeda"
                }
            },
            required: ["query"]
        }
    }
];

async function chatWithTools(messages, availableTools = FUNCTION_DEFINITIONS) {
    /**
     * Chat con function calling habilitado
     * El modelo decide autom√°ticamente cu√°ndo usar herramientas
     */
    
    try {
        const response = await openai.chat.completions.create({
            model: "gpt-4o",
            messages: messages,
            tools: availableTools.map(tool => ({
                type: "function",
                function: tool
            })),
            tool_choice: "auto"  // El modelo decide cu√°ndo usar tools
        });
        
        const message = response.choices[0].message;
        
        // Si el modelo quiere usar una funci√≥n
        if (message.tool_calls) {
            const toolResults = [];
            
            for (const toolCall of message.tool_calls) {
                const functionName = toolCall.function.name;
                const functionArgs = JSON.parse(toolCall.function.arguments);
                
                console.log(`üõ†Ô∏è Ejecutando funci√≥n: ${functionName}`, functionArgs);
                
                // Ejecutar funci√≥n
                const functionResponse = await AVAILABLE_FUNCTIONS[functionName](functionArgs);
                
                toolResults.push({
                    tool_call_id: toolCall.id,
                    role: "tool",
                    name: functionName,
                    content: JSON.stringify(functionResponse)
                });
            }
            
            // Continuar conversaci√≥n con resultados de funciones
            const secondResponse = await openai.chat.completions.create({
                model: "gpt-4o",
                messages: [
                    ...messages,
                    message,
                    ...toolResults
                ]
            });
            
            return {
                response: secondResponse.choices[0].message.content,
                toolsUsed: message.tool_calls.map(tc => tc.function.name),
                usage: secondResponse.usage
            };
        }
        
        // Respuesta directa sin usar tools
        return {
            response: message.content,
            toolsUsed: [],
            usage: response.usage
        };
        
    } catch (error) {
        console.error('Error en chat con tools:', error.message);
        throw error;
    }
}

// ============================================
// üß† MEMORIA A LARGO PLAZO (persistente)
// ============================================

// Esta funci√≥n se conectar√≠a a PostgreSQL para guardar/cargar memoria
async function saveMemory(userId, agentId, key, value) {
    /**
     * Guardar informaci√≥n en memoria persistente
     * Ejemplo: preferencias del usuario, contexto empresarial
     */
    
    // TODO: Implementar con PostgreSQL
    console.log(`üíæ Guardando memoria: ${userId}:${agentId}:${key}`);
    
    return {
        saved: true,
        key: key,
        userId: userId,
        agentId: agentId
    };
}

async function loadMemory(userId, agentId, key) {
    /**
     * Cargar informaci√≥n de memoria persistente
     */
    
    // TODO: Implementar con PostgreSQL
    console.log(`üß† Cargando memoria: ${userId}:${agentId}:${key}`);
    
    return {
        value: null,
        found: false
    };
}

// ============================================
// üìä EXPORTAR FUNCIONES
// ============================================

module.exports = {
    // B√∫squeda y datos actualizados
    webSearch,
    
    // Im√°genes
    analyzeImage,
    generateImage,
    
    // C√≥digo
    executeCode,
    
    // Documentos
    analyzeDocument,
    
    // Function calling
    chatWithTools,
    FUNCTION_DEFINITIONS,
    AVAILABLE_FUNCTIONS,
    
    // Memoria
    saveMemory,
    loadMemory
};
